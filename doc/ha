pub file:
    send ip file
    write ip file
    read ip file

是否应该建立一个无状态的服务器，通用协议
    haha
    hehe






data replications:
当一个备份不可用时，查询其他备份。设置超时时间。
Meta查询，如何判断

Meta存储在M，数据有三个备份: R1, R2, R3， 用户A

1.会话与连接
应用层的会话必须是跨tcp连接的。一个socket并不能成为一个会话。因为请求之间通常有较长时间的
间隔，几十秒，几分钟甚至一二个小时，tcp连接会因空闲而失效。

facebook, douban等基于http协议的接口与此类似。每个http请求都是一个tcp连接。多个请求构成一次
会话。直接基于socket的接口可以尽可能的复用已建立的socket，省去tcp三次握手网络开销。只有原
socket失效的情况下，才建立一个新的。
A connect M 获取一个socket

2.错误处理
当请求发送接受失败的时候，通常表明有网络故障。处理方法如下:
a. 关闭原有socket，建立尝试一定次数创建新socket。
b. 如果成功，则重新传输请求。
c. 如果失败，则表明为长时间网络故障或对方节点死机。此时有三种选择
c.1 报告失败，关闭会话
c.2 等待对方恢复，需要等待较长时间，与重新尝试连接有何不同？
c.3 重定位到另一个拥有同样数据备份的节点R2。如何确定一个节点是否有效？

3.发送请求
检测原socket是否有效，如果失效则建立新socket
调用recv发送req
将请求req发到等待ack确认队列
异步模式立即返回，同步模式等待一直到该req.status为error，timeout，committed

4.接收线程
socket建立之后，创建一个线程专门负责读取。处理接收来的消息，更改其对应请求的状态，并将其放到
合适的队列上


服务器：
1. 接受请求
检测是否为重复请求
发送ack确认，不需要等待用户收到该ack的确认。如果用户长时间没有收到，则会重新发送请求，而服务器
    检测出重复请求。
完成后发送done确认
写入固定存储后发送committed确认

最后两步是否有必要？

简直是tcp协议的翻版？是否有必要？是否可以去掉ack确认这个环节？用户A如果在一定时间内收不到结果，
则可以自由选择重新传输或者出错放弃。类似于现有的基于http协议的接口。
ack可以和done状态合并，但是如果执行的时间比较长的话，ack可以使用户端快速的知道req已收到。

简单化:
facebook接口要么成功返回结果，要么什么也不返回，用户端的表现就是网络故障，自由选择是重试还是报告
错误。服务器端会自动清除超时的会话，死机后自己决定是否进行recovery，以及何种程度的recovery。用户
对此是没有概念的，用户所做的只是根据自己的意愿进行重传，并没有意识到服务器是否在recovery。


现在我们要做的网络部分与此类似，只是recovery需要服务器和用户之间的配合。

高可用性体现于
网络暂时性故障透明处理：重试等待
长时间故障分钟级，节点死机透明处理: 等待恢复，或者重定向到有相同数据的其他节点
这个似乎不应该是由客户端来处理，服务器端使用一个集群来提供可靠的服务。动态会话迁移？如果一个请求在由
load balancer分配后，执行过程中出错： 客户端重试？ 服务器切换到备份机？ 服务器重启恢复？

当出现故障时系统自动选择重试和恢复，等待网络恢复或者对方节点重启，上层应用读写函数感觉不到错误的
发生，故障被屏蔽了。 自动重启后恢复recovery相当于系统的自修复。

可用级别：
facebook  服务器死机后，恢复日志，只是使系统恢复到一致状态。对于用户会话是否恢复，用户是否能感觉到
这次死机？

ha：
用户感觉不到死机，不间断服务

假设服务器重启后的日志恢复可以到时间点t，那么只要保证所有的请求在提交到日志之后，才返回给用户，恢复
阶段就不需要用户的参与。用户最多只能得到时间点t之前的返回结果。


考虑这样一种情况：
C发送req
S收到req，发送ack，开始执行
C收到ack
S发送done
C收到done，超时
S此时是否将结果写入磁盘，发送committed？

C取消操作应该发送cancel到S
C超时的时候是否应该发送cancel到S？

服务器收到cancel操作是否应该有ack？

tcp只是保证在网络良好的情况，如果收到数据，则数据一定是正确连续的。如果出错，则不会收到数据。


如何保证在会话层次的可靠传输？ 比tcp空闲超时时间要长的多。可借鉴tcp的解决方案。双方都ack。
不管是req，还是ack，done, committed等上层状态，只在消息抽象层次上保证可靠性


